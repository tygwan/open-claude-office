# DXTnavis - Experience Blocks

> Generated by experience-interviewer | 2026-02-22
> Source: analysis/narrative.md + analysis/architecture.md + user interview

---

## Experience 1: COM API Property Write

> .NET API의 read-only 제약을 COM API 브릿지로 돌파

### 목표 (KPI)
- **What**: Navisworks 모델 오브젝트에 커스텀 프로퍼티를 쓰기 (4D 시뮬레이션 태깅용)
- **KPI**: 프로퍼티 쓰기 성공률, 오류 없는 파이프라인 실행
- **맥락**: 이 기능 없이는 AWP 4D 자동화 파이프라인 전체가 불가능

### 현상 (문제 증상)
- .NET API (`Autodesk.Navisworks.Api`)에는 프로퍼티 write 메서드 자체가 없음
- PropertyCategory에 setter가 존재하지 않아 커스텀 프로퍼티 생성 불가
- .NET API로 쓰기를 시도하면 예외(ReadOnly) 발생
- 근거: `Services/PropertyWriteService.cs:88-133`, `docs/adr/ADR-001-ComAPI-Property-Write.md`

### 원인 가설 (Top 3)
1. **Autodesk 설계 의도**: .NET API는 read-only viewer/inspector 용도로 설계. Write는 COM API에만 노출 (legacy 호환)
2. **보안/안정성 이유**: .NET API에서 모델 수정 허용 시 플러그인 간 충돌/데이터 손상 위험
3. **API 버전 차이**: COM API가 먼저 존재했고, .NET API는 후발 래퍼로서 write 기능을 포팅하지 않음

### 판단 기준 (Decision Rule)
- **시행착오 과정**: .NET API write 시도 → ReadOnly 예외 발생 → COM API 탐색
- **대안 비교**:
  - External DB 매핑: 별도 싱크 필요 → 복잡도 ↑ (기각)
  - IFC 파일 직접 수정: 원본 파괴적 → 위험 (기각)
  - COM API `SetUserDefined()`: 공식 지원 메서드, non-destructive → **채택**
- **결정 근거**: COM API는 유일하게 프로퍼티 write를 공식 지원하는 경로

### 실행 (실험/적용)
- COM API 브릿지 구현: `ComApiBridge.State` → `InwGUIPropertyNode2.SetUserDefined()`
- COMException 대응: retry 로직 추가 (`PropertyWriteService.cs:54-83`)
- Dual API 전략 확립: Read=.NET, Write=COM (ADR-005)
- ADR-001 문서화: `docs/adr/ADR-001-ComAPI-Property-Write.md`

### 결과 (숫자 + 변화 + 비교)
- **Before**: 프로퍼티 쓰기 불가 → 4D 자동화 파이프라인 자체가 불가능
- **After**: COM API로 커스텀 프로퍼티 쓰기 성공 → 5단계 파이프라인 완성
- **부수 효과**: Dual API 패턴이 프로젝트 전체 아키텍처 원칙으로 정착
- **제약**: COM interop은 COMException/AccessViolationException 위험 → retry 로직 필수

---

## Experience 2: AccessViolationException 핸들링

> Navisworks API의 불안정한 프로퍼티 접근을 graceful degradation으로 해결

### 목표 (KPI)
- **What**: 어떤 BIM 모델이든 크래시 없이 프로퍼티 추출 완료
- **KPI**: 플러그인 크래시율 0%, 데이터 추출 완료율 95%+
- **맥락**: 프로퍼티 추출은 모든 기능의 기반 — 여기서 크래시하면 플러그인 자체가 무용

### 현상 (문제 증상)
- 특정 프로퍼티 카테고리 접근 시 `System.AccessViolationException` 발생
- 특정 벤더/포맷의 커스텀 프로퍼티에서 집중 발생
- 일반 try-catch로 잡히지 않음 (CLR 보호 예외)
- 크래시 시 Navisworks 전체 프로세스 종료
- 근거: `Services/NavisworksDataExtractor.cs:30-31`, `Services/NavisworksDataExtractor.cs:87-102`

### 원인 가설 (Top 3)
1. **벤더별 프로퍼티 구현 차이**: 특정 벤더(Tekla, CATIA 등)의 커스텀 프로퍼티가 Navisworks API 내부에서 잘못된 메모리 접근 유발
2. **네이티브 코드 충돌**: Navisworks 내부의 C++ 네이티브 코드와 .NET managed 코드 사이 마샬링 에러
3. **해제된 COM 객체 접근**: 모델 탐색 중 이미 해제된 COM 객체의 프로퍼티에 접근

### 판단 기준 (Decision Rule)
- **핵심 판단**: 크래시 방지가 데이터 완전성보다 우선
- **대안 비교**:
  - 문제 카테고리 블랙리스트: 모델마다 다름 → 유지보수 불가 (기각)
  - API 호출 전 검증: 검증 메서드 자체도 AVE 발생 가능 (기각)
  - `[HandleProcessCorruptedStateExceptions]` + skip-and-continue: CLR 수준에서 포착 가능 → **채택**
- **트레이드오프 수용**: 일부 프로퍼티 skip → 데이터 손실 < 1% (수용 가능)

### 실행 (실험/적용)
- `[HandleProcessCorruptedStateExceptions]` + `[SecurityCritical]` 어트리뷰트 적용
- 모든 프로퍼티 접근을 개별 try-catch로 래핑
- skip-and-continue 로직: 실패한 프로퍼티 건너뛰고 로그 기록
- 근거: `NavisworksDataExtractor.cs:30-31`, `NavisworksDataExtractor.cs:87-102`

### 결과 (숫자 + 변화 + 비교)
- **Before**: 특정 모델 로드 시 Navisworks 전체 크래시
- **After**: 크래시율 0% — 어떤 모델이든 안전하게 로드
- **데이터 손실률**: < 1% (skip된 프로퍼티는 대부분 사용하지 않는 벤더 내부 메타데이터)
- **패턴 정착**: 모든 Navisworks API 호출에 방어적 예외 처리 적용

---

## Experience 3: 445K → 5K 성능 최적화

> WPF 데이터 바인딩 병목을 데이터 구조 재설계로 99% 해소

### 목표 (KPI)
- **What**: 실제 건설 프로젝트 규모(40만+ 프로퍼티)의 BIM 모델을 실용적 속도로 처리
- **KPI**: Select All < 1초, 필터링 응답 < 500ms, UI 프리즈 0회
- **맥락**: 프로토타입은 소규모 모델에서 잘 동작 → 실제 규모에서 성능 벽

### 현상 (문제 증상)
- 445,000개 프로퍼티 레코드 로드 시 WPF ObservableCollection 바인딩 붕괴
- Select All 클릭 → 수 분간 UI 프리즈
- 필터링/정렬 작업에서도 초 단위 지연
- 실사용 불가능 수준
- 근거: `CHANGELOG.md:237-264`, Phase 12 refactoring

### 원인 가설 (Top 3)
1. **자연스러운 시작점 문제**: 프로퍼티 하나 = 행 하나(flat)가 직관적이라 채택. 소규모에서 문제 없었으나 스케일에서 붕괴
2. **WPF DataGrid 한계**: ObservableCollection의 개별 아이템 변경 알림이 445K번 발생 → UI 스레드 포화
3. **O(n) 반복 연산**: Select All, Filter 등이 전체 컬렉션을 순회 → n=445K에서 실용적 시간 초과

### 판단 기준 (Decision Rule)
- **핵심 판단**: 데이터 구조 자체를 변경해야 함 (UI 수준 최적화로는 한계)
- **대안 비교**:
  - VirtualizingStackPanel (가상화): 렌더링은 개선되나 Select All 등 데이터 연산은 여전히 느림 (기각)
  - Pagination: BIM 워크플로우에서 페이지 넘기기는 UX 파괴적 (기각)
  - Grouped Data Structure: 1 오브젝트 = 1 그룹 (N개 프로퍼티) → 반복 대상 5K로 감소 → **채택**
- **결정 근거**: 문제는 렌더링이 아니라 데이터 모델 — 근본적 재설계 필요

### 실행 (실험/적용)
- `ObjectGroupModel` 도입: 오브젝트 단위 그룹핑 (`Models/ObjectGroupModel.cs`)
- `NavisworksDataExtractor` 리팩토링: grouped extraction (`NavisworksDataExtractor.cs:617-843`)
- v1.0.0으로 메이저 버전 업 — 데이터 구조 변경의 중요성 반영
- 근거: commit `f070dd1`, `3ebc3f4`

### 결과 (숫자 + 변화 + 비교)
- **Before**: 445K records, Select All 수 분, UI 프리즈 빈번
- **After**: ~5K groups, Select All 즉시, UI 프리즈 0
- **개선율**: iteration count 99% 감소 (445K → 5K)
- **버전**: v1.0.0 — 프로젝트 첫 메이저 릴리스로 마킹

---

## Experience 4: AWP 4D 자동화 파이프라인

> 수동 7단계 4D 시뮬레이션 설정을 3단계 원클릭 자동화로 변환

### 목표 (KPI)
- **What**: BIM 모델에 일정 데이터를 자동으로 연결하여 4D 시뮬레이션(TimeLiner) 생성
- **KPI**: 워크플로우 단계 수 감소, 수동 작업 시간 감소
- **맥락**: POC/데모 수준 — 기능 완성 후 실 프로젝트 적용 계획 중
- **이중 목적**: 실무 도구 + BIM 자동화 기술 역량 증명

### 현상 (문제 증상)
- 기존 Navisworks 4D 설정: 수동 7+ 단계 (CSV 준비 → 오브젝트 선택 → 프로퍼티 확인 → 매칭 → 태깅 → Selection Set → TimeLiner)
- 단계마다 수동 클릭/확인 필요
- 오류 발생 시 처음부터 재시작
- 대형 모델일수록 비례적으로 시간 증가

### 원인 가설 (Top 3)
1. **Navisworks 설계 철학**: 범용 도구라 특정 도메인(AWP 4D) 워크플로우 최적화가 안 되어 있음
2. **API 파편화**: Read(.NET) / Write(COM) / TimeLiner(별도) API가 분리되어 통합 자동화가 어려움
3. **검증 부재**: 수동 과정에서 매칭 오류/누락 검증이 불가 → 오류 축적

### 판단 기준 (Decision Rule)
- **핵심 판단**: 5단계 파이프라인으로 전 과정을 자동화하되, 각 단계에 검증/DryRun 포함
- **파이프라인 설계 이유**:
  - 단일 서비스: 유지보수 어려움, 테스트 불가 (기각)
  - 독립 서비스 5개: 각 단계 독립 실행/테스트 가능, 에러 격리 용이 → **채택**
- **DryRun 결정**: 실제 Write 전에 매칭 결과를 미리 보여줌 → 사용자 검증 가능

### 실행 (실험/적용)
- 5-phase pipeline: CSV Parse → Object Match → Property Write → Selection Set → TimeLiner
- 7개 신규 서비스 클래스 + 4개 모델 클래스 (단일 커밋 `efcd237`)
- Validation + DryRun + Progress Tracking + Error Recovery
- Phase 13-14에서 Direct Execution 추가 (CSV 중간 단계 제거 → 7단계 → 3단계)
- 근거: `Services/AWP4DAutomationService.cs:51-300`, `ScheduleBuilderViewModel.cs:751-926`

### 결과 (숫자 + 변화 + 비교)
- **Before**: 수동 7+ 단계, 단계별 수동 클릭, 오류 검증 불가
- **After**: 자동 3단계 (선택 → 설정 → 실행), DryRun으로 사전 검증
- **워크플로우 감소**: 57% (7단계 → 3단계)
- **상태**: POC/데모 수준 완성 — 실 프로젝트 적용 계획 중
- **아키텍처 영향**: Service Layer 패턴이 프로젝트 전체로 확산

---

## Experience 5: Synthetic ID Generation

> BIM 포맷 간 GUID 불일치를 결정적 합성 ID로 해결

### 목표 (KPI)
- **What**: 모든 BIM 포맷(IFC, CATIA, PDMS 등)에서 일관된 오브젝트 식별자 보장
- **KPI**: Hierarchy 보존율 100%, 세션 간 ID 일관성
- **맥락**: Ontology 매핑(bim-ontology)에서 안정적 URI 생성의 전제 조건

### 현상 (문제 증상)
- CATIA, PDMS 등 일부 BIM 포맷에서 `InstanceGuid`가 `Guid.Empty`
- Hierarchy(부모-자식 관계)가 무너짐
- Ontology 매핑 시 URI 생성 불가
- 근거: `Services/Geometry/GeometryExtractor.cs:271-404`, `CHANGELOG.md:113-147`

### 원인 가설 (Top 3)
1. **포맷별 스펙 차이**: IFC는 GlobalId 필수이지만, CATIA/PDMS는 자체 ID 체계 사용 → Navisworks 변환 시 GUID 미생성
2. **Navisworks 변환기 한계**: 임포트 시 네이티브 ID를 InstanceGuid로 매핑하지 않는 변환기 존재
3. **레거시 데이터**: 오래된 BIM 파일은 GUID 개념 자체가 없던 시절에 생성

### 판단 기준 (Decision Rule)
- **발견 계기**: IFC/BIM 스펙 리서치 중 GUID 부재 가능성을 사전에 인지
- **핵심 판단**: 결정적(deterministic) ID가 필요 — 같은 입력 → 같은 ID
- **대안 비교**:
  - Random GUID: 세션마다 달라짐 → 온톨로지 매핑 불일치 (기각)
  - Index-based ID: 모델 수정 시 인덱스 변동 → 불안정 (기각)
  - MD5(SourceGuid + AuthoringID/HierarchyPath): 결정적 + 충돌 확률 극저 → **채택**
- **결정 근거**: 온톨로지 URI의 일관성이 최우선 요구사항

### 실행 (실험/적용)
- MD5 해시 기반 결정적 GUID 생성: `MD5(ModelSourceGuid + AuthoringID or HierarchyPath)`
- Fallback 체인: InstanceGuid → AuthoringID → HierarchyPath 순서
- `GeometryExtractor.cs:271-404`에 구현
- v1.3.0으로 릴리스

### 결과 (숫자 + 변화 + 비교)
- **Before**: CATIA/PDMS 모델에서 hierarchy 붕괴, 온톨로지 매핑 불가
- **After**: 모든 BIM 포맷에서 일관된 ID 보장
- **결정성**: 동일 모델 재로드 시 동일 ID 생성 확인
- **bim-ontology 연동**: 안정적 URI 생성 기반 확보 → 온톨로지 프로젝트 진행 가능

---

## Experience 6: Geometry Export & Ontology Bridge

> Navisworks BIM 데이터를 3D 시각화/지식그래프 시스템으로 연결하는 브릿지 구축

### 목표 (KPI)
- **What**: BIM 모델의 기하학 데이터(BBox, Centroid, Mesh)를 외부 시스템에서 소비 가능한 형태로 추출
- **KPI**: Three.js/CesiumJS 호환 포맷, 온톨로지 통합 가능 구조
- **이중 목적**: (1) bim-ontology에서 공간 데이터 필요 (2) 웹 기반 BIM 시각화 가능성 확보

### 현상 (문제 증상)
- Navisworks 데이터는 프로퍼티 + 계층구조만 추출 가능 → 3D 위치/형상 정보 부재
- bim-ontology에서 공간 질의(Spatial Query)에 기하학 데이터 필요
- 웹 기반 BIM 뷰어 구축 시 geometry 데이터 필요
- 기존 추출 파이프라인은 속성 데이터만 다룸

### 원인 가설 (Top 3)
1. **API 분리**: Navisworks에서 프로퍼티와 geometry는 별도 API 경로로 접근
2. **Mesh 복잡도**: 전체 Mesh 추출은 데이터 크기/처리 시간이 급격히 증가 → BBox가 실용적 첫 단계
3. **포맷 호환성**: Three.js manifest.json 형식이 이미 표준화되어 있어 BBox 기반으로 즉시 활용 가능

### 판단 기준 (Decision Rule)
- **BBox 우선 결정**: Mesh는 구현 복잡도와 데이터 크기가 크므로, BBox/Centroid로 먼저 80%의 공간 질의를 커버
- **Unified CSV 결정**: 계층구조 + 프로퍼티 + 기하학을 하나의 CSV로 병합 → 온톨로지 변환 파이프라인 단순화
- **manifest.json 포맷**: Three.js/CesiumJS/deck.gl 호환 형식 채택 → 웹 시각화 즉시 연동 가능

### 실행 (실험/적용)
- Phase 15: BoundingBox 추출 시스템 + manifest.json + Geometry CSV
- Phase 16: Unified CSV Export (계층 + 기하학 병합)
- RDF geometry 통합: BSO/GeoSPARQL 어휘 연동
- MeshExtractor 구현 (COM API): `Services/Geometry/MeshExtractor.cs` (테스트 필요)
- 근거: `CHANGELOG.md:10-97`, commits `ba2a33a`, `35dabdf`

### 결과 (숫자 + 변화 + 비교)
- **Before**: 프로퍼티/계층 데이터만 추출 가능 → 3D 위치 정보 부재
- **After**: BBox/Centroid 추출 + manifest.json + Unified CSV 완성
- **bim-ontology 연동**: Unified CSV → RDF 변환 파이프라인 가능
- **상태**: BBox 완성, Mesh는 구현 완료 but 테스트 필요
- **다음 단계**: 실제 웹 뷰어 프로토타입 + Mesh export 검증

---

## Gap Summary

| # | 경험 | 목표 | 현상 | 원인가설 | 판단기준 | 실행 | 결과 | 완성도 |
|---|------|:----:|:----:|:--------:|:--------:|:----:|:----:|:------:|
| 1 | COM API Property Write | O | O | O | O | O | O | 100% |
| 2 | AccessViolationException | O | O | O | O | O | O | 100% |
| 3 | 445K → 5K 성능 최적화 | O | O | O | O | O | O | 100% |
| 4 | AWP 4D 자동화 파이프라인 | O | O | O | O | O | O | 100% |
| 5 | Synthetic ID Generation | O | O | O | O | O | O | 100% |
| 6 | Geometry Export & Bridge | O | O | O | O | O | O | 100% |

**Overall**: 6/6 experiences complete (100%)

---

## Interview Notes

- COM API 발견: 시행착오 과정 (.NET write 시도 → 예외 발생 → COM API 탐색)
- AVE 패턴: 특정 벤더/포맷의 커스텀 프로퍼티 카테고리에서 집중 발생
- 445K 최적화: flat이 자연스러운 시작점이었으나 스케일에서 붕괴 → 근본적 구조 변경
- 4D Pipeline: POC/데모 수준 완성, 실 프로젝트 적용 계획 중
- Synthetic ID: IFC/BIM 스펙 리서치에서 사전에 GUID 부재 가능성 인지
- Geometry Export: bim-ontology(공간 데이터) + 웹 시각화 두 가지 동기
- 프로젝트 전체 목표: 실무 도구 + 기술 역량 증명 (이중 목적)
